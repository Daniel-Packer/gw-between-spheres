import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns
import numpy as np
from src.benchmarks import sphere_gw_distance
import json
import pathlib
from typing import Optional, Literal
import os

PLOT_PATH = pathlib.Path("./plots")


def make_method_pretty(method_name: str):
    return method_name[:3].upper()


def get_relative_error(estimate: pd.DataFrame, true_value: pd.DataFrame):
    return (estimate - true_value) / estimate


def get_absolute_error(estimate: pd.DataFrame, true_value: pd.DataFrame):
    return estimate - true_value


def get_mean_res(gw_method: str, raw_data):
    metadata, data = raw_data["metadata"], raw_data["data"]
    dim_range = metadata["dim_range"]
    trials = {}
    for ix, m in enumerate(dim_range):
        trials[m] = {}
        for n in dim_range[:ix]:
            trials[m][n] = np.mean(
                list(map(lambda x: x[1][gw_method], data[str(m)][str(n)].items()))
            )
    return trials


def plot_trial_outcomes(
    trial_outcome_path: pathlib.Path, plot_path: Optional[pathlib.Path], **kwargs
):
    """Plots the content of the json file stored at the inputted path. The json
    file should be generated by the function `benchmarks.benchmarking_run`.

    Args:
        trial_outcome_path (pathlib.Path): The path to the json file.
        plot_path (pathlib.Path | None): The path in which to put the plot (if
        it is set as None, then it will default to `./plots`).
        **kwargs: Keyword arguments for setting properties of the resulting
        plot via the `plt.Axes.set` function.

    """
    plot_path = plot_path if plot_path is not None else PLOT_PATH
    trial_dict = json.load(open(trial_outcome_path, "r"))

    metadata = trial_dict["metadata"]
    sphere_dim_1 = metadata["sphere_dimension_1"]
    sphere_dim_2 = metadata["sphere_dimension_2"]
    sampling_strategy = metadata["subsampling_strategy"]
    n_trials = metadata["n_trials"]

    trial_outcomes = trial_dict["data"]
    new_trial_outcome_dict = {
        (outerKey, innerKey): values
        for outerKey, innerDict in trial_outcomes.items()
        for innerKey, values in innerDict.items()
    }
    trial_outcomes_df = (
        pd.DataFrame(new_trial_outcome_dict)
        .T.reset_index(names=["Sample Size", "Trial"])
        .rename(
            columns={"pot_estimate": "POT", "ott_estimate_reg0.01": "OTT (reg=0.01)"}
        )
        .astype(float)
    )

    lower_quantile = (
        trial_outcomes_df[["Sample Size", "POT", "OTT (reg=0.01)"]]
        .groupby("Sample Size")
        .agg(lambda x: np.quantile(x, 0.1))
    )

    upper_quantile = (
        trial_outcomes_df[["Sample Size", "POT", "OTT (reg=0.01)"]]
        .groupby("Sample Size")
        .agg(lambda x: np.quantile(x, 0.9))
    )

    mean = (
        trial_outcomes_df[["Sample Size", "POT", "OTT (reg=0.01)"]]
        .groupby("Sample Size")
        .mean()
    )

    fig, ax = plt.subplots()
    ax: plt.Axes = ax
    sns.lineplot(
        data=mean,
        x="Sample Size",
        y="POT",
        label="POT (CGD, no reg)",
        color="C0",
        ax=ax,
    )
    sns.lineplot(
        data=mean,
        x="Sample Size",
        y="OTT (reg=0.01)",
        label="OTT (reg=0.01)",
        color="C1",
        ax=ax,
    )
    plt.fill_between(
        lower_quantile.index,
        lower_quantile["POT"],
        upper_quantile["POT"],
        color="C0",
        alpha=0.3,
    )
    plt.fill_between(
        lower_quantile.index,
        lower_quantile["OTT (reg=0.01)"],
        upper_quantile["OTT (reg=0.01)"],
        color="C1",
        alpha=0.3,
    )

    ax.axhline(
        sphere_gw_distance(sphere_dim_1, sphere_dim_2),
        color="black",
        linestyle="--",
        label="True Distance",
    )

    ax.legend()

    ax.set(
        title=f"Distance Between Random Points on $S^{sphere_dim_1}$ and $S^{sphere_dim_2}$\n(Subsampling strategy is {sampling_strategy})",
        xlabel="Number of Sampled Points",
        ylabel="Computed Distance",
        **kwargs,
    )

    try:
        plt.savefig(
            plot_path
            / f"{sampling_strategy}_trials"
            / f"n_{n_trials}_d_{sphere_dim_1}_d{sphere_dim_2}.png"
        )
    except FileNotFoundError:
        os.mkdir(plot_path / f"{sampling_strategy}_trials")
        plt.savefig(
            plot_path
            / f"{sampling_strategy}_trials"
            / f"n_{n_trials}_d_{sphere_dim_1}_d{sphere_dim_2}.png"
        )


def make_dimension_plot(
    trial_data_path: pathlib.Path,
    gw_method: str,
    plot_path: Optional[pathlib.Path] = None,
    error_type: Literal["relative", "absolute"] = "relative",
    **kwargs,
):
    plot_path = plot_path if plot_path is not None else PLOT_PATH
    with open(trial_data_path, "r") as f:
        raw_data = json.load(f)

    metadata = raw_data["metadata"]
    subsampling_strategy = metadata["subsampling_strategy"]
    n_samples = metadata["num_samples"]
    n_trials = metadata["n_trials"]

    estimate_df = pd.DataFrame.from_dict(get_mean_res(gw_method, raw_data)).dropna(
        axis=1, how="all"
    )
    true_df = pd.DataFrame.from_dict(get_mean_res("true_distance", raw_data)).dropna(
        axis=1, how="all"
    )

    if error_type == "relative":
        error = get_relative_error(estimate_df, true_df)
    if error_type == "absolute":
        error = get_absolute_error(estimate_df, true_df)

    if error is None:
        raise TypeError("`error_type` should be either 'relative' or 'absolute'")

    fig, ax = plt.subplots()
    ax: plt.Axes = ax
    sns.heatmap(error, ax=ax, annot=True, center=0.0)
    ax.set(
        aspect="equal",
        title=f"Relative error of mean prediction of {n_trials} trials,\nusing {make_method_pretty(gw_method)} and {n_samples} point {subsampling_strategy} sampling.",
        xlabel="Larger sphere dimension",
        ylabel="Smaller sphere dimension",
        **kwargs,
    )
    plt.tight_layout()

    plt.savefig(plot_path / f"dimensions_{gw_method}_{subsampling_strategy}.png")
